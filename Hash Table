import java.io.*;
import java.util.*;

public class Open_Addressing {
     public int m; // number of SLOTS AVAILABLE
     public int A; // the default random number
     int w;
     int r;
     public int[] Table;

     protected Open_Addressing(int w, int seed, int A) {

         this.w = w;
         this.r = (int) (w-1)/2 +1;
         this.m = power2(r);
         if (A==-1){
            this.A = generateRandom((int) power2(w-1), (int) power2(w),seed);
         }
        else{
            this.A = A;
        }
         this.Table = new int[m];
         for (int i =0; i<m; i++) {
             Table[i] = -1;
         }
         
     }
     
                 /** Calculate 2^w*/
     public static int power2(int w) {
         return (int) Math.pow(2, w);
     }
     public static int generateRandom(int min, int max, int seed) {     
         Random generator = new Random(); 
                 if(seed>=0){
                    generator.setSeed(seed);
                 }
         int i = generator.nextInt(max-min-1);
         return i+min+1;
     }
        /**Implements the hash function g(k)*/
        public int probe(int key, int i) {
            int h_k = (int) ((((long) A * (long) key) % power2(w)) >> (w - r));
            return ((h_k + i) % m + m) % m; //making sure index is negative
    }
     
     
     /**Inserts key k into hash table. Returns the number of collisions encountered*/
        public int insertKey(int key) {
        int collisions = 0;
        int index = probe(key, 0);

        while (collisions < m) { // Prevent infinite loops
            if (Table[index] == -1 || Table[index] == -2) { // If empty or deleted slot
                Table[index] = key;
                return collisions; // Return number of collisions
            }
            collisions++;
            index = probe(key, collisions); // Proper linear probing
        }
        return m; // Hash table is full
    }
        
        /**Sequentially inserts a list of keys into the HashTable. Outputs total number of collisions */
        public int insertKeyArray (int[] keyArray){
            int collision = 0;
            for (int key: keyArray) {
                collision += insertKey(key);
            }
            return collision;
        }
            
         /**Removes key k from the hash table. Returns the number of collisions encountered*/
        public int removeKey(int key) {

            int collisions = 0; //collisions tracked
            int index= probe(key, 0); // indexing probe 
            

            while(Table[index] !=-1 && Table[index] != -2 && Table[index]!= key &&  collisions <= this.m) { // Probe up to m times
                collisions++;
                index++;
                index = index%this.m;   

                if (Table[index] == key) { // key found
                Table[index] = -2; // mark as deleted
                return collisions; // return number of collisions before finding the key
                }
            }

            if (Table[index] == -1) { // stop searching when an empty slot is reached
                return collisions+1; // key is not in the table
            }
            if (collisions >= this.m){
                return this.m;
            }
            return m;

        }
}
